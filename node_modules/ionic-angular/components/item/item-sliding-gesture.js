"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var dom_1 = require('../../util/dom');
var ui_event_manager_1 = require('../../util/ui-event-manager');
var gesture_controller_1 = require('../../gestures/gesture-controller');
var DRAG_THRESHOLD = 10;
var MAX_ATTACK_ANGLE = 20;
var ItemSlidingGesture = (function () {
    function ItemSlidingGesture(list) {
        this.list = list;
        this.preSelectedContainer = null;
        this.selectedContainer = null;
        this.openContainer = null;
        this.events = new ui_event_manager_1.UIEventManager(false);
        this.panDetector = new PanXRecognizer(DRAG_THRESHOLD, MAX_ATTACK_ANGLE);
        this.gesture = list.gestureCtrl.create('item-sliding', {
            priority: gesture_controller_1.GesturePriority.Interactive,
        });
        this.pointerEvents = this.events.pointerEvents({
            element: list.getNativeElement(),
            pointerDown: this.pointerStart.bind(this),
            pointerMove: this.pointerMove.bind(this),
            pointerUp: this.pointerEnd.bind(this),
        });
    }
    ItemSlidingGesture.prototype.pointerStart = function (ev) {
        if (this.selectedContainer) {
            return false;
        }
        // Get swiped sliding container
        var container = getContainer(ev);
        if (!container) {
            this.closeOpened();
            return false;
        }
        // Close open container if it is not the selected one.
        if (container !== this.openContainer) {
            this.closeOpened();
        }
        // Try to start gesture
        if (!this.gesture.start()) {
            this.gesture.release();
            return false;
        }
        var coord = dom_1.pointerCoord(ev);
        this.preSelectedContainer = container;
        this.panDetector.start(coord);
        this.firstCoordX = coord.x;
        this.firstTimestamp = Date.now();
        return true;
    };
    ItemSlidingGesture.prototype.pointerMove = function (ev) {
        if (this.selectedContainer) {
            this.onDragMove(ev);
            return;
        }
        var coord = dom_1.pointerCoord(ev);
        if (this.panDetector.detect(coord)) {
            if (this.panDetector.isPanX() && this.gesture.capture()) {
                this.onDragStart(ev, coord);
                return;
            }
            // Detection/capturing was not successful, aborting!
            this.closeOpened();
            this.pointerEvents.stop();
        }
    };
    ItemSlidingGesture.prototype.pointerEnd = function (ev) {
        this.gesture.release();
        if (this.selectedContainer) {
            this.onDragEnd(ev);
        }
        else {
            this.closeOpened();
        }
    };
    ItemSlidingGesture.prototype.onDragStart = function (ev, coord) {
        var container = getContainer(ev);
        if (!container) {
            console.debug('onDragStart, no itemContainerEle');
            return false;
        }
        ev.preventDefault();
        this.selectedContainer = this.openContainer = this.preSelectedContainer;
        container.startSliding(coord.x);
    };
    ItemSlidingGesture.prototype.onDragMove = function (ev) {
        var coordX = dom_1.pointerCoord(ev).x;
        ev.preventDefault();
        this.selectedContainer.moveSliding(coordX);
    };
    ItemSlidingGesture.prototype.onDragEnd = function (ev) {
        ev.preventDefault();
        var coordX = dom_1.pointerCoord(ev).x;
        var deltaX = (coordX - this.firstCoordX);
        var deltaT = (Date.now() - this.firstTimestamp);
        var openAmount = this.selectedContainer.endSliding(deltaX / deltaT);
        this.selectedContainer = null;
        this.preSelectedContainer = null;
    };
    ItemSlidingGesture.prototype.closeOpened = function () {
        this.selectedContainer = null;
        this.gesture.release();
        if (this.openContainer) {
            this.openContainer.close();
            this.openContainer = null;
            return true;
        }
        return false;
    };
    ItemSlidingGesture.prototype.destroy = function () {
        this.gesture.destroy();
        this.events.unlistenAll();
        this.closeOpened();
        this.list = null;
        this.preSelectedContainer = null;
        this.selectedContainer = null;
        this.openContainer = null;
    };
    return ItemSlidingGesture;
}());
exports.ItemSlidingGesture = ItemSlidingGesture;
function getContainer(ev) {
    var ele = dom_1.closest(ev.target, 'ion-item-sliding', true);
    if (ele) {
        return ele['$ionComponent'];
    }
    return null;
}
var AngleRecognizer = (function () {
    function AngleRecognizer(threshold) {
        this._angle = null;
        this.threshold = Math.pow(threshold, 2);
    }
    AngleRecognizer.prototype.start = function (coord) {
        this.startCoord = coord;
        this._angle = 0;
        this.dirty = true;
    };
    AngleRecognizer.prototype.angle = function () {
        return this._angle;
    };
    AngleRecognizer.prototype.detect = function (coord) {
        if (!this.dirty) {
            return false;
        }
        var deltaX = (coord.x - this.startCoord.x);
        var deltaY = (coord.y - this.startCoord.y);
        var distance = deltaX * deltaX + deltaY * deltaY;
        if (distance >= this.threshold) {
            this._angle = Math.atan2(deltaY, deltaX);
            this.dirty = false;
            return true;
        }
        return false;
    };
    return AngleRecognizer;
}());
var PanXRecognizer = (function (_super) {
    __extends(PanXRecognizer, _super);
    function PanXRecognizer(threshold, maxAngle) {
        _super.call(this, threshold);
        this.maxAngle = maxAngle * (Math.PI / 180);
    }
    PanXRecognizer.prototype.start = function (coord) {
        _super.prototype.start.call(this, coord);
        this._isPanX = false;
    };
    PanXRecognizer.prototype.isPanX = function () {
        return this._isPanX;
    };
    PanXRecognizer.prototype.detect = function (coord) {
        if (_super.prototype.detect.call(this, coord)) {
            var angle = Math.abs(this.angle());
            this._isPanX = (angle < this.maxAngle || Math.abs(angle - Math.PI) < this.maxAngle);
            return true;
        }
        return false;
    };
    return PanXRecognizer;
}(AngleRecognizer));