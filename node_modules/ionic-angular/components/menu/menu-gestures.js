"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var slide_edge_gesture_1 = require('../../gestures/slide-edge-gesture');
var util_1 = require('../../util/util');
var gesture_controller_1 = require('../../gestures/gesture-controller');
var DEGREES_TO_RADIANS = Math.PI / 180;
var MIN_COSINE = Math.cos(40 * DEGREES_TO_RADIANS);
/**
 * Gesture attached to the content which the menu is assigned to
 */
var MenuContentGesture = (function (_super) {
    __extends(MenuContentGesture, _super);
    function MenuContentGesture(menu, contentEle, options) {
        if (options === void 0) { options = {}; }
        _super.call(this, contentEle, util_1.assign({
            direction: 'x',
            edge: menu.side,
            threshold: 0,
            maxEdgeStart: menu.maxEdgeStart || 75
        }, options));
        this.menu = menu;
        this.gesture = menu.gestureCtrl.create('menu-swipe', {
            priority: gesture_controller_1.GesturePriority.NavigationOptional,
        });
    }
    MenuContentGesture.prototype.canStart = function (ev) {
        if (this.shouldStart(ev)) {
            return this.gesture.capture();
        }
        this.gesture.release();
        return false;
    };
    MenuContentGesture.prototype.shouldStart = function (ev) {
        var menu = this.menu;
        if (!menu.enabled || !menu.swipeEnabled) {
            console.debug('menu can not start, isEnabled:', menu.enabled, 'isSwipeEnabled:', menu.swipeEnabled, 'side:', menu.side);
            return false;
        }
        if (ev.distance > 50) {
            // the distance is longer than you'd expect a side menu swipe to be
            console.debug('menu can not start, distance too far:', ev.distance, 'side:', menu.side);
            return false;
        }
        console.debug('menu shouldCapture,', menu.side, 'isOpen', menu.isOpen, 'angle', ev.angle, 'distance', ev.distance);
        if (menu.isOpen) {
            return true;
        }
        var cosine = Math.cos(ev.angle * DEGREES_TO_RADIANS);
        if (menu.side === 'right') {
            if (cosine < -MIN_COSINE) {
                return _super.prototype.canStart.call(this, ev);
            }
        }
        else {
            if (cosine > MIN_COSINE) {
                return _super.prototype.canStart.call(this, ev);
            }
        }
        return false;
    };
    // Set CSS, then wait one frame for it to apply before sliding starts
    MenuContentGesture.prototype.onSlideBeforeStart = function (slide, ev) {
        console.debug('menu gesture, onSlideBeforeStart', this.menu.side);
        this.menu.swipeStart();
    };
    MenuContentGesture.prototype.onSlide = function (slide, ev) {
        var z = (this.menu.side === 'right' ? slide.min : slide.max);
        var stepValue = (slide.distance / z);
        console.debug('menu gesture, onSlide', this.menu.side, 'distance', slide.distance, 'min', slide.min, 'max', slide.max, 'z', z, 'stepValue', stepValue);
        ev.srcEvent.preventDefault();
        ev.preventDefault();
        this.menu.swipeProgress(stepValue);
    };
    MenuContentGesture.prototype.onSlideEnd = function (slide, ev) {
        this.gesture.release();
        var z = (this.menu.side === 'right' ? slide.min : slide.max);
        var currentStepValue = (slide.distance / z);
        z = Math.abs(z * 0.5);
        var shouldCompleteRight = (ev.velocityX >= 0)
            && (ev.velocityX > 0.2 || slide.delta > z);
        var shouldCompleteLeft = (ev.velocityX <= 0)
            && (ev.velocityX < -0.2 || slide.delta < -z);
        console.debug('menu gesture, onSlide', this.menu.side, 'distance', slide.distance, 'delta', slide.delta, 'velocityX', ev.velocityX, 'min', slide.min, 'max', slide.max, 'shouldCompleteLeft', shouldCompleteLeft, 'shouldCompleteRight', shouldCompleteRight, 'currentStepValue', currentStepValue);
        this.menu.swipeEnd(shouldCompleteLeft, shouldCompleteRight, currentStepValue);
    };
    MenuContentGesture.prototype.getElementStartPos = function (slide, ev) {
        if (this.menu.side === 'right') {
            // right menu
            return this.menu.isOpen ? slide.min : slide.max;
        }
        // left menu
        return this.menu.isOpen ? slide.max : slide.min;
    };
    MenuContentGesture.prototype.getSlideBoundaries = function () {
        if (this.menu.side === 'right') {
            // right menu
            return {
                min: -this.menu.width(),
                max: 0
            };
        }
        // left menu
        return {
            min: 0,
            max: this.menu.width()
        };
    };
    MenuContentGesture.prototype.unlisten = function () {
        this.gesture.release();
        _super.prototype.unlisten.call(this);
    };
    MenuContentGesture.prototype.destroy = function () {
        this.gesture.destroy();
        _super.prototype.destroy.call(this);
    };
    return MenuContentGesture;
}(slide_edge_gesture_1.SlideEdgeGesture));
exports.MenuContentGesture = MenuContentGesture;
/**
 * Gesture attached to the actual menu itself
 */
var MenuTargetGesture = (function (_super) {
    __extends(MenuTargetGesture, _super);
    function MenuTargetGesture(menu, menuEle) {
        _super.call(this, menu, menuEle, {
            maxEdgeStart: 0
        });
        this.gesture.priority++;
    }
    return MenuTargetGesture;
}(MenuContentGesture));
exports.MenuTargetGesture = MenuTargetGesture;