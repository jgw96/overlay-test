"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var util_1 = require('../../util/util');
var gesture_controller_1 = require('../../gestures/gesture-controller');
var slide_edge_gesture_1 = require('../../gestures/slide-edge-gesture');
var SwipeBackGesture = (function (_super) {
    __extends(SwipeBackGesture, _super);
    function SwipeBackGesture(element, options, _nav, gestureCtlr) {
        _super.call(this, element, util_1.assign({
            direction: 'x',
            maxEdgeStart: 75
        }, options));
        this._nav = _nav;
        this.gesture = gestureCtlr.create('goback-swipe', {
            priority: gesture_controller_1.GesturePriority.Navigation,
        });
    }
    SwipeBackGesture.prototype.canStart = function (ev) {
        this.gesture.release();
        // the gesture swipe angle must be mainly horizontal and the
        // gesture distance would be relatively short for a swipe back
        // and swipe back must be possible on this nav controller
        return (ev.angle > -40 &&
            ev.angle < 40 &&
            ev.distance < 50 &&
            this._nav.canSwipeBack() &&
            _super.prototype.canStart.call(this, ev) &&
            this.gesture.capture());
    };
    SwipeBackGesture.prototype.onSlideBeforeStart = function (slideData, ev) {
        console.debug('swipeBack, onSlideBeforeStart', ev.srcEvent.type);
        this._nav.swipeBackStart();
    };
    SwipeBackGesture.prototype.onSlide = function (slide) {
        var stepValue = (slide.distance / slide.max);
        console.debug('swipeBack, onSlide, distance', slide.distance, 'max', slide.max, 'stepValue', stepValue);
        this._nav.swipeBackProgress(stepValue);
    };
    SwipeBackGesture.prototype.onSlideEnd = function (slide, ev) {
        var shouldComplete = (Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5);
        var currentStepValue = (slide.distance / slide.max);
        console.debug('swipeBack, onSlideEnd, shouldComplete', shouldComplete, 'currentStepValue', currentStepValue);
        this._nav.swipeBackEnd(shouldComplete, currentStepValue);
        this.gesture.release();
    };
    SwipeBackGesture.prototype.unlisten = function () {
        this.gesture.release();
        _super.prototype.unlisten.call(this);
    };
    SwipeBackGesture.prototype.destroy = function () {
        this.gesture.destroy();
        _super.prototype.destroy.call(this);
    };
    return SwipeBackGesture;
}(slide_edge_gesture_1.SlideEdgeGesture));
exports.SwipeBackGesture = SwipeBackGesture;